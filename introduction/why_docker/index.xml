<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pourquoi docker ? on Docker et Orchestration</title><link>https://zaggash.github.io/tp-iut-docker/introduction/why_docker/</link><description>Recent content in Pourquoi docker ? on Docker et Orchestration</description><generator>Hugo -- gohugo.io</generator><language>fr-fr</language><lastBuildDate>Mon, 08 Jun 2020 23:09:18 +0200</lastBuildDate><atom:link href="https://zaggash.github.io/tp-iut-docker/introduction/why_docker/index.xml" rel="self" type="application/rss+xml"/><item><title>Deploiements complexes</title><link>https://zaggash.github.io/tp-iut-docker/introduction/why_docker/complex_deployments/</link><pubDate>Mon, 08 Jun 2020 23:09:18 +0200</pubDate><guid>https://zaggash.github.io/tp-iut-docker/introduction/why_docker/complex_deployments/</guid><description>Les deploiements deviennent de plus en plus compliqués, voici quelques exemples.
De nombreuses couches applicatives:
Language (php, go, JS,&amp;hellip;) Framework Bases de données Plusieurs environnements cibles:
Machines locales pour les tests Environnements de Dev, QA, Pre-Prod, Prod Serveurs locaux, Cloud</description></item><item><title>Deploiements simplifiés</title><link>https://zaggash.github.io/tp-iut-docker/introduction/why_docker/easier_deployments/</link><pubDate>Mon, 08 Jun 2020 23:09:18 +0200</pubDate><guid>https://zaggash.github.io/tp-iut-docker/introduction/why_docker/easier_deployments/</guid><description>Une application construite dans une image peut tourner n&amp;rsquo;importe où.
Cela simplifie la chaine de deploiement et assure que l&amp;rsquo;application soit la même partout où elle s&amp;rsquo;execute.
Un conteneur retire les problématiques de dépendances, de différences de paquets entre les OS, de configurations qui différent.
On oublie le fameux: &amp;ldquo;Moi, ca marche sur ma machine&amp;hellip;&amp;rdquo;</description></item><item><title>Avant Docker</title><link>https://zaggash.github.io/tp-iut-docker/introduction/why_docker/before_docker/</link><pubDate>Mon, 08 Jun 2020 23:09:18 +0200</pubDate><guid>https://zaggash.github.io/tp-iut-docker/introduction/why_docker/before_docker/</guid><description>Les applications étaient principalement toutes installées sur des Machines Virtuelles.
Certaines fois plusieurs applications partagent la même VM avec ses propres librairies, dépendances, fichiers de configurations&amp;hellip;
Les installations se sont ensuite automatisées avec Ansible, Chef, Puppet,&amp;hellip; mais il est très facile de modifier un fichier directement sur la machine sans changer le template.
Ce qui rend les environnements certaines fois non fiable.
Les Ops et Dev n&amp;rsquo;ont pas forcement une manière simple de partager les applications.</description></item><item><title>Après Docker</title><link>https://zaggash.github.io/tp-iut-docker/introduction/why_docker/after_docker/</link><pubDate>Mon, 08 Jun 2020 23:09:18 +0200</pubDate><guid>https://zaggash.github.io/tp-iut-docker/introduction/why_docker/after_docker/</guid><description>Les applications sont désormais deployées seules dans une image avec les dependances et configurations.
Dev et Prod peuvent facilement echanger l&amp;rsquo;application et la deployer en Production.
Les mises à jour ne neccessitent plus une reinstallation mais seulement un changement d&amp;rsquo;image.
De la même maniere, il est désormais très simple de revenir à une version précédente.</description></item><item><title>Alors, VM ou Conteneur ?</title><link>https://zaggash.github.io/tp-iut-docker/introduction/why_docker/vm_container/</link><pubDate>Mon, 08 Jun 2020 23:09:18 +0200</pubDate><guid>https://zaggash.github.io/tp-iut-docker/introduction/why_docker/vm_container/</guid><description>La plupart du temps, les conteneurs tournent dans des VMs.
Les applications profitent des bénéfices de la contenerisation et la flexibilité des VMs.
Faire tourner des conteneurs dans une machine complétement physique ajoute des problématiques de scalabilitée.
Il n&amp;rsquo;y a pas de vérité, tout est une question de besoin !
VM Conteneur Lourd, dans l&amp;rsquo;ordre du Giga Léger, dans l&amp;rsquo;ordre du Mega Overhead de l&amp;rsquo;hyperviseur Performance native de l&amp;rsquo;hôte Chaque VMs à son propre OS Les conteneurs partagent l&amp;rsquo;OS de l&amp;rsquo;hôte Virtualisation Hardware Virtualisation de l&amp;rsquo;OS Démarrage dans l&amp;rsquo;ordre de la minute Démarrage de l&amp;rsquo;ordre de la milliseconde Isolation complète, donc plus sécrisée Isolation au niveau du processus, potentiellement moins sécurisée</description></item></channel></rss>